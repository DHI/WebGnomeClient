define([
    'jquery',
    'underscore',
    'backbone'
], function($, _, Backbone){
    var baseModel = Backbone.Model.extend({
        /*
         Add an array of field names here that should be converted to strings
         during `toJSON` calls and to `moment` objects during `get` calls.
         */
        dateFields: null,

        schema: null,

        initialize: function(attrs, opts) {
            this.dirty = false;
            this.bind('change', this.change, this);
            this.bind('change:id', this.onIndexChange, this);

            BaseModel.__super__.initialize.apply(this, arguments);

            if (opts && opts.gnomeModel) {
                this.gnomeModel = opts.gnomeModel;
                prependWithGnomeUrl.call(this);
            }
        },

        // Allow only empty or schema-compliant attributes
        //
        // Inspired by:
        //      https://github.com/salsita/backbone-schema/blob/master/lib/backbone-schema.js#L41
        validate: function(attrs) {
            if (!this.schema) {
                return null;
            }

            // JSV defaults to JSON Schema draft 3 by default.
            var env = JSV.createEnvironment();

            // Resulting model consists of attributes we already have set and
            // the attributes provided as argument to this function (merged).
            // When an attribute is `unset`, it is passed in `attrs` object,
            // the attribute has special value of `undefined`. To learn how the
            // resulting object will look like, we need to:
            // + merge the already-set attributes with the new ones, and
            // + remove the attributes that are to be unset.
            var obj = _.extend({}, this.attributes, attrs);

            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    if ('undefined' === typeof obj[key]) {
                        delete obj[key];
                    }
                }
            }

            if (_.isEmpty(obj)) {
                return;
            }

            obj = this.jsonify(obj);
            var r = env.validate(obj, this.schema);

            if (!r.errors.length) {
                return null;
            }

            var errors = [];

            for (var i = 0; i < r.errors.length; i++) {
                var error = r.errors[i];
                errors.push(this.formatSchemaError(error));
            }

            return errors;
        },

        schemaErrorDescriptionTemplates: {
            'type': 'Value should be a {{-error.details}}',
            'type_many': 'Value should be one of these types: {{-error.details}}',
            'minimum': 'Value should be at least: {{-error.details}}',
            'maximum': 'Value should be at most: {{-error.details}}'
        },

        /*
         Format a JSON Schema error generated by JSV `error` with a description
         that we can show directly to a user.
         */
        formatSchemaError: function(error) {
            var uriParts = error.uri.split('/');
            var description = error.message;
            var attribute = error.attribute;

            if (attribute == 'type' && error.details.length > 1) {
                attribute = 'type_many';
            }

            var template = this.schemaErrorDescriptionTemplates[attribute];

            if (template) {
                template = _.template(template);
                description = template({error: error});
            }

            return {
                description: description,
                // Field name is the last part of the URI
                name: uriParts[uriParts.length - 1]
            }
        },

        onIndexChange: function() {
            if (this.collection && this.collection.comparator) {
                this.collection.sort({silent: true});
            }
        },

        /*
         Keep an array field on the model in sync with a field that represents
         one item in the array.

         E.g. given a `start_position` field that is an array, the model might
         have a `start_position_x` field that we use for easier data binding
         in views. The following usage of `syncArrayField` will keep
         `start_position` up to date with the latest value of `start_position_x`:
         at index 0 and vice versa.

                syncArrayField('start_position', 'start_position_x', 0);
         */
        syncArrayField: function(arrayFieldName, arrayItemFieldName, index) {

            function setArrayField(model) {
                var arrayField = model.get(arrayFieldName);
                arrayField[index] = model.get(arrayItemFieldName);
                this.set(arrayFieldName, arrayField);
            }

            function setArrayItemField(model) {
                var arrayField = model.get(arrayFieldName);
                model.set(arrayItemFieldName, arrayField[index]);
            }

            this.on('change:' + arrayItemFieldName, setArrayField);
            this.on('change:' + arrayFieldName, setArrayItemField);

            var arrayField = this.get(arrayFieldName);

            if (arrayField && arrayField.length) {
                setArrayItemField(this);
            }
        },

        change: function() {
            this.dirty = true;
        },

        save: function(attrs, options) {
            options = options || {};
            var _this = this;

            if (!_.has(options, 'wait')) {
                options.wait = true;
            }

            if (_.has(options, 'success')) {
                var success = options.success;

                options.success = function(model, response, options) {
                    _this.success(model, response, options);
                    success(model, response, options);
                }
            } else {
                options.success = this.success;
            }

            if (!_.has(options, 'error')) {
                options.error = this.error;
            }

            return BaseModel.__super__.save.apply(this, [attrs, options]);
        },

        success: function(model, response, options) {
            model.errors = null;
            model.dirty = false;
        },

        destroy: function(options) {
            options = options || {};

            if (!_.has(options, 'wait')) {
                options.wait = true;
            }

            BaseModel.__super__.destroy.apply(this, [options]);
        },

        error: function(model, response, options) {
            try {
                response = $.parseJSON(response.responseText);
            } catch(e) {
                response.errors = [{
                    name: 'server',
                    description: 'A server error prevented saving the model.'
                }];
            }

            if (response && response.errors.length) {
                model.errors = response.errors;
                model.set(model.previousAttributes());
            }
        },

        fetch: function(options) {
            options = options || {};

            if (!_.has(options, 'success')) {
                options.success = this.success
            }

            return BaseModel.__super__.fetch.apply(this, [options]);
        },

        parse: function(response) {
            var message = util.parseMessage(response);
            if (message) {
                this.trigger(BaseModel.MESSAGE_RECEIVED, message);
            }

            var data = BaseModel.__super__.parse.apply(this, arguments);

            // Convert date fields from strings into `moment` objects.
            if (this.dateFields) {
                _.each(this.dateFields, function(field) {
                    if (typeof(data[field] === "string")) {
                        data[field] = moment(data[field]);
                    }
                });
            }

            return data;
        },

         // Return a `moment` object for any date field.
        get: function(attr) {
            var val = BaseModel.__super__.get.apply(this, arguments);

            if(val && this.dateFields && _.contains(this.dateFields, attr)) {
                var date = moment(val);
                if (date && date.isValid()) {
                    return date;
                } else {
                    return val;
                }
            }

            return val;
        },

        /*
         Call .format() on any date fields when preparing them for JSON
         serialization.

         Included in a separate method so it can be called during validation.
         */
        jsonify: function(data) {
            if (this.dateFields) {
                _.each(this.dateFields, function(field) {
                    if (typeof(data[field]) === "string") {
                        return;
                    }

                    if (data[field]) {
                        data[field] = data[field].format();
                    }
                });
            }

            return data;
        },

        toJSON: function() {
            var data = BaseModel.__super__.toJSON.apply(this, arguments);
            return this.jsonify(data);
        }
    }, {
        MESSAGE_RECEIVED: 'ajaxForm:messageReceived'
    });

    return baseModel;
});